import random
import pickle
import re
import requests
from bs4 import BeautifulSoup
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackContext, CallbackQueryHandler
from telegram.helpers import escape_markdown  # Built-in Telegram markdown escaping

# 🔹 Replace with your bot token
TELEGRAM_BOT_TOKEN = "7242491692:AAHOM0562JVPxufbIheM0EuCEzXv-ZUqWe8"  # 🚨 Replace with your actual bot token

# 🔹 Log chat (Group/Channel) ID for logging generated emails
LOG_CHAT_ID = -4699240803  # 🚨 Replace with your log chat ID

# 🔹 Email generator base URL
EMAIL_GENERATOR_URL = "https://generator.email"

# 🔹 Fixed domain for email generation
DOMAIN = "doteluxe.com"

# 🔹 Lists for random username generation
FIRST_NAMES = ["james", "sophia", "michael", "olivia", "william", "emma", "john", "ava"]
ADJECTIVES = ["cool", "stormy", "silent", "brave", "shadow", "fast", "golden"]

# 🔹 File to store generated emails persistently
EMAIL_STORAGE_FILE = "generated_emails.pkl"

# Load previously generated emails
try:
    with open(EMAIL_STORAGE_FILE, "rb") as f:
        generated_emails = pickle.load(f)
except FileNotFoundError:
    generated_emails = set()


def escape_markdown_v2(text):
    """Escape special characters for Telegram MarkdownV2."""
    escape_chars = r'_*\[\]()~`>#+-=|{}.!'
    return re.sub(f'([{re.escape(escape_chars)}])', r'\\\1', text)


def generate_random_username() -> str:
    """Generate a random username."""
    return f"{random.choice(FIRST_NAMES)}{random.choice(ADJECTIVES)}{random.randint(1000, 9999)}"


def generate_random_email() -> str:
    """Generate a unique random email."""
    while True:
        email = f"{generate_random_username()}@{DOMAIN}"
        if email not in generated_emails:
            generated_emails.add(email)
            return email


def fetch_email_content(email: str) -> str:
    """Fetch the latest email using requests and BeautifulSoup."""
    try:
        inbox_url = f"{EMAIL_GENERATOR_URL}/{email}"
        response = requests.get(inbox_url, timeout=10)

        if response.status_code == 200:
            soup = BeautifulSoup(response.text, "html.parser")
            email_table = soup.find("div", id="email-table")

            if email_table:
                email_content = email_table.get_text(strip=True)
                return email_content[:1000]  # Limit message length
            return "📭 No emails received yet."
        return "⚠️ Failed to fetch email content."
    except requests.RequestException:
        return "⚠️ Error fetching email content."


async def start(update: Update, context: CallbackContext) -> None:
    """Send a welcome message."""
    await update.message.reply_text(
        "👋 Welcome to the Email Generator Bot!\n\n"
        "Use the following commands:\n"
        "➡️ `/generate` - Create a new email\n"
        "➡️ `/check_email your_email@doteluxe.com` - Check inbox"
    )


async def generate_email(update: Update, context: CallbackContext) -> None:
    """Generate a new email and send the details with a button."""
    user = update.effective_user
    user_mention = f"@{user.username}" if user.username else user.first_name
    email = generate_random_email()

    # ✅ Escape MarkdownV2 properly
    escaped_email = escape_markdown_v2(email)
    escaped_user = escape_markdown_v2(user_mention)

    email_text = (
        f"📧 *Your new email is:*\n`{escaped_email}`\n\n"
        f"📥 *Inbox URL:* [Open Inbox]({EMAIL_GENERATOR_URL}/{escaped_email})\n\n"
        f"➡️ Generate another: `/generate`\n"
        f"📬 Check inbox: `/check_email {escaped_email}`\n\n"
        f"Generated by {escaped_user}"
    )

    keyboard = [[InlineKeyboardButton("Generate Another Email", callback_data="generate")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(email_text, parse_mode="MarkdownV2", reply_markup=reply_markup)
    await context.bot.send_message(chat_id=LOG_CHAT_ID, text=email_text, parse_mode="MarkdownV2")


async def check_email(update: Update, context: CallbackContext) -> None:
    """Check the inbox for a given email."""
    if not context.args:
        await update.message.reply_text("❌ Please provide an email address.\nExample: `/check_email your_email@doteluxe.com`")
        return

    email = context.args[0]
    escaped_email = escape_markdown_v2(email)
    email_content = fetch_email_content(email)
    escaped_content = escape_markdown_v2(email_content)

    user = update.effective_user
    user_mention = f"@{user.username}" if user.username else user.first_name
    escaped_user = escape_markdown_v2(user_mention)

    message_text = (
        f"📧 *Inbox for:* `{escaped_email}`\n\n"
        f"📥 *Latest Email Content:*\n{escaped_content}\n\n"
        f"Generated by {escaped_user}"
    )

    await update.message.reply_text(message_text, parse_mode="MarkdownV2")
    await context.bot.send_message(chat_id=LOG_CHAT_ID, text=message_text, parse_mode="MarkdownV2")


async def button_handler(update: Update, context: CallbackContext) -> None:
    """Handle button presses."""
    query = update.callback_query
    await query.answer()

    if query.data == 'generate':
        user = update.effective_user
        user_mention = f"@{user.username}" if user.username else user.first_name
        email = generate_random_email()

        escaped_email = escape_markdown_v2(email)
        escaped_user = escape_markdown_v2(user_mention)

        email_text = (
            f"📧 *Your new email is:*\n`{escaped_email}`\n\n"
            f"📥 *Inbox URL:* [Open Inbox]({EMAIL_GENERATOR_URL}/{escaped_email})\n\n"
            f"➡️ Generate another: `/generate`\n"
            f"📬 Check inbox: `/check_email {escaped_email}`\n\n"
            f"Generated by {escaped_user}"
        )

        keyboard = [[InlineKeyboardButton("Generate Another Email", callback_data="generate")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.message.reply_text(email_text, parse_mode="MarkdownV2", reply_markup=reply_markup)
        await context.bot.send_message(chat_id=LOG_CHAT_ID, text=email_text, parse_mode="MarkdownV2")


def main() -> None:
    """Start the bot."""
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("generate", generate_email))
    application.add_handler(CommandHandler("check_email", check_email))
    application.add_handler(CallbackQueryHandler(button_handler))

    print("🤖 Bot is running...")
    application.run_polling()

    # Save generated emails when bot stops
    with open(EMAIL_STORAGE_FILE, "wb") as f:
        pickle.dump(generated_emails, f)
    print("✅ Generated emails saved.")


if __name__ == "__main__":
    main()